package eight_and_seven_kyu;
/*
Переставить слова наоборот

Завершите функцию, которая принимает строковый параметр и
переворачивает каждое слово в строке. Все пробелы в строке должны быть сохранены.

Примеры
"This is an example!" ==> "sihT si na !elpmaxe"
"double  spaces"      ==> "elbuod  secaps"
*/

import java.util.Arrays;
import java.util.stream.Collectors;

public class ReverseWords {
    public static String reverseWords(final String original) {
        // Разбиваем строку на массив подстрок, включая пробелы как отдельные элементы
        // (?<=\\s) - позитивный просмотр назад (разделение после пробела)
        // | - или
        // (?=\\s+) - позитивный просмотр вперед (разделение перед пробелом/ами)
        String[] splitStrings = original.split("(?<=\\s)|(?=\\s+)");

        // Преобразуем массив в поток (Stream) строк
        return Arrays.stream(splitStrings)
                // Для каждого элемента потока (слова или пробела)
                .map(str ->
                        // Создаем StringBuilder, переворачиваем строку и преобразуем обратно в String
                        new StringBuilder(str).reverse().toString()
                )
                // Собираем поток обратно в одну строку
                .collect(Collectors.joining());
    }

    public static void main(String[] args) {
        // Тест 1: переворот слов с обычными пробелами
        System.out.println(reverseWords("This is an example!")); // "sihT si na !elpmaxe"

        // Тест 2: переворот слов с двойными пробелами
        System.out.println(reverseWords("double  spaces"));      // "elbuod  secaps"
    }
}

/*
Дополнительная пометка для данного примера

Особенности работы регулярного выражения:

(?<=\\s) - это "позитивный просмотр назад" (positive lookbehind):
Находит место в строке, которое следует после пробела
Но сам пробел не "съедается", а включается в результат разбиения

| - означает логическое "ИЛИ" в регулярных выражениях

(?=\\s+) - это "позитивный просмотр вперед" (positive lookahead):
Находит место в строке, перед которым идет один или несколько пробелов
Пробелы также сохраняются в результате разбиения

Почему это важно?
Благодаря такому подходу:
-Слова и пробелы становятся отдельными элементами массива
-При переворачивании пробелы остаются на своих местах
-Сохраняется точное количество пробелов между словами

Пример разбиения:
Для строки "hello world" (с двумя пробелами):
Разбиение даст массив: ["hello", " ", "world"]
После переворота: ["olleh", " ", "dlrow"]
После сборки: "olleh dlrow"

*/